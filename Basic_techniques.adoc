== Basic techniques


=== How to represent links

==== Problem

How can a client discover relevant resources at runtime?

==== Solution

Use links represented in a `@controls` element with URLs to the relevant resources.

==== Discussion

Use links to bind different resources together. Links represent relations such as "parent-of" between resources. The use
of links in representations allows a client to discover related resources on the fly - instead of hard coding the client with knowledge of the URL structures used.

Building clients that discover URLs on the fly opens up for some really nice improvements:

* Client developers can explores the resources to get a better understanding of them - without having to read any documentation. The returned representations may even contain inline documentation right where the client developers need it.

* The server can off-load certain resources to Content Delivery Networks or other servers that better handle the load of specific resources.

* The server can add tracking, signatures and authorization elements to URLs without having to modify clients.

* The client can interact with different independent implementations of the same service even though they reside on different servers with different URL structures.

===== Documentation

Documentation for links should only describe the link relation type - which in Mason means the control name. The actual URL structure used is not relavant for the client as this will be discoved at runtime.

==== Example

Here we have the representation of a single issue from the issue tracker. It contains links to itself (the "self" linke), its parent project (the "up" link) and its own list of attachments (the "is:attachments" link):

----
{
  "@namespaces":{
    "is":{
      "name":"http://elfisk.dk/mason/issue-tracker/reltypes.html#"
    }
  },
  "@controls":{
    "self":{
      "href":"http://issue-tracker.org/issues/1"
    },
    "up":{
      "title":"Containing project",
      "href":"http://issue-tracker.org/projects/1"
    },
    "is:attachments":{
      "title":"All attachments for this issue",
      "href":"http://issue-tracker.org/issues/1/attachments"
    },
  }
}
----


// ----------------------------------------------------------------------
=== How to shorten control names with curies

==== Problem

Custom control names are too long and clutters readability of the JSON source. How can the it be made more readable?

==== Solution

Use CURIES (Compact URIs) to shorten control names.

==== Discussion

Compact URIs or "CURIEs" for short is a standard way of shortening URIs as described in http://www.w3.org/TR/2009/CR-curie-20090116/. A CURIE is comprised of two components, a prefix and a reference. The prefix is separated from the reference by a colon (:) - like for instance "is:attachments" where "is" is the prefix and "attachments" is the reference. In Mason the prefix refers to a namespace declaration in the `@meta` section.

A CURIE is expanded into a full URI by looking up the prefix in the namespace declarations and substituting the prefix with the "name" value of the namespace (and removing the colon).

All CURIEs in Mason MUST be expanded to URIs by the client before looking for control names.

CURIES are not used for `href` values in hypermedia controls.

==== Example

Here we have a namespace declaration that maps from "is" to "http://elfisk.dk/mason/issue-tracker/reltypes.html#" and one single link named "is:attachments". If we expand the prefix "is" we get the link name "http://elfisk.dk/mason/issue-tracker/reltypes.html#attachments" which in this representation is equivalent to "is:attachments".

----
{
  "@namespaces":{
    "is":{
      "name":"http://elfisk.dk/mason/issue-tracker/reltypes.html#"
    }
  },
  "@controls":{
    "is:attachments":{
      "title":"All attachments for this issue",
      "href":"http://issue-tracker.org/issues/1/attachments"
    },
  }
}
----


// ----------------------------------------------------------------------
=== How to represent URL templates

==== Problem

How can clients discover URLs that depends on values supplied by the client?

==== Solution

Use templated URLs represented as a `@controls` element with a templated `href` value.

==== Discussion

URL templates instruct clients (at runtime) about URL construction from a well known set of variables - as for instance a query where the client is supposed to include query parameters in the URL and then GET that resource.

A URL template in Mason is declared as a `@control` element with the `isHrefTemplate` property set to `true`. This indicates to the client that the related `href` value is to be interpreted as a URL template.

The rules for variable substitution in URL templates are described in https://tools.ietf.org/html/rfc6570[RFC 6570 - URI Template].

A JSON schema definition can be used to described the variables used in the URL template. This is not a required feature as the variable names can be parsed from the template itself but a JSON schema makes it possible to generate automatic user interfaces on the fly - similar to HTML forms but without all the layout features.

All the values for the template variables should be represented in a JSON object. Variable names are then supposed to be JSONPath expressions (without leading slashes) that refer to properties in the JSON object.

===== Documentation

Documentation of URL templates should declare the control name, the expected variables and their usage.

==== Example

The example here contains the URL template control named "is:issue-query" which represents a query for issues in the common issue tracker example. It refers to three different variables `text`, `severity` and `pid`. All of the variables are described in the embedded JSON schema definition.

----
{
  "@namespaces":{
    "is":{
      "name":"http://elfisk.dk/mason/issue-tracker/reltypes.html#"
    }
  },
  "@controls":{
    "is:issue-query":{
      "title":"Search for issues",
      "description":"This is a simple search that do not check attachments.",
      "href":"http://issue-tracker.org/issues-query?text={text}&severity={severity}&project={pid}",
      "isHrefTemplate":true,
      "schema":{
        "properties":{
          "text":{
            "description":"Substring search for text in title and description",
            "type":"string"
          },
          "severity":{
            "description":"Issue severity (exact value, 1..5)",
            "type":"int"
          },
          "pid":{
            "description":"Project ID",
            "type":"int"
          }
        }
      }
    }
  }
}
----

If the client supplies the variables as a JSON object as the one below then the expanded URL becomes "http://issue-tracker.org/issues-query?text=ABC&severity=3&project=17".

----
{
  "text": "ABC",
  "severity": 3,
  "pid": 17
}
----

// ----------------------------------------------------------------------
=== How to represent actions

==== Problem

How can clients discover available actions and their operational details?

==== Solution

Use @controls elements to describe each possible action including both HTTP method and JSON payload.

==== Discussion

Hypermedia APIs that allow clients to modify content needs some way to represent the possible operations. At the most 

==== Example



// ----------------------------------------------------------------------
=== How to handle file uploads (TBD)

==== Problem


==== Solution


==== Discussion


==== Example



// ----------------------------------------------------------------------
=== How to represent a home document (TBD)

==== Problem


==== Solution


==== Discussion


==== Example


